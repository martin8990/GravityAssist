#pragma kernel CalculateHeight

#include "noiseSimplex.cginc"



struct Biome
{
    float height;
    float t;
    float amplitude;
    float smoothness;
    float seed;
    float4 color;

};

float BiomeGradient;
float BiomeAmplitude;
float BiomeSmoothness;
float BiomeSeed;
float warpOffset;
float warpMult;
float deltaMax;

int deltaArea;
int TextureResolution;
int nBiomes;
int Center;

Texture2D<float> gt[2];

RWTexture2D<float4> Result;
RWStructuredBuffer<Biome> BiomeBuffer;
RWStructuredBuffer<float> heightMap;


float fractalize(float amplitude,float seed, float smoothness, int2 id)
{
   
    const int octaves = 3;
    float frequency = 1.0 / smoothness;
    
    float y = 0;
    for (int i = 0; i < octaves; i++)
    {
        y += amplitude * snoise(id.xy*frequency + seed);
        frequency *= 2;
        amplitude *= 1.0 / 2; 
    }
    return y + 0.5f;
}

float FractalizeAndPreturb(float amplitude, float seed, float smoothness, int2 id,float warpOffset,float warpMult)
{
 	float2 q = float2(fractalize(amplitude, seed, smoothness, id), fractalize(amplitude, seed, smoothness, id + warpOffset));
	return fractalize(amplitude, seed, smoothness, id + warpMult * q);
}


[numthreads(8, 8, 1)]
void CalculateHeight(uint3 id : SV_DispatchThreadID)
{
    float biome_t = FractalizeAndPreturb(BiomeAmplitude, BiomeSeed, BiomeSmoothness, id.xy,warpOffset,warpMult)  - distance(id.xy,Center) * BiomeGradient;
    Biome lowerBiome = BiomeBuffer[0];
    Biome upperBiome = BiomeBuffer[nBiomes - 1];
    float lower_t = -1e14;
    float upper_t = 1e14;
    for (int i = 0; i < nBiomes; i++)
    {
        Biome biome = BiomeBuffer[i];
        if (biome.t < biome_t && biome.t > lower_t)
        {
            lowerBiome = biome;
            lower_t = biome.t;
        }
        else if (biome.t > biome_t && biome.t < upper_t)
        {
            upperBiome = biome;
            upper_t = biome.t;
        }
    }
    float t = (biome_t - lower_t) / (upper_t - lower_t);
    
    float lowerHeight = lowerBiome.height + FractalizeAndPreturb(lowerBiome.amplitude, lowerBiome.seed, lowerBiome.smoothness, id.xy, warpOffset,warpMult);
    float upperHeight = upperBiome.height + FractalizeAndPreturb(upperBiome.amplitude, upperBiome.seed, upperBiome.smoothness, id.xy, warpOffset, warpMult);
	float myHeight = lerp(lowerHeight, upperHeight, t);
	heightMap[id.x + id.y * TextureResolution] = myHeight;

    AllMemoryBarrierWithGroupSync();
    
    float avg = 0;
    float deltaAvg = 0;
    
    for (int x = -deltaArea; x <= deltaArea; x++)
    {
        for (int y = -deltaArea; y <= deltaArea; y++)
        {
            float val = heightMap[id.x + x + (id.y + y) * TextureResolution];
            avg = avg + val;
            deltaAvg += abs(myHeight - val);
        }
    }
    float div = ((2 * deltaArea + 1) * (2 * deltaArea + 1));
    avg = avg / div;
    deltaAvg /= div;
    float slopeDamp_t = pow(deltaAvg / deltaMax, 2);
    myHeight = lerp(myHeight, avg, slopeDamp_t);
	
    Result[id.xy] = float4(lerp(lowerBiome.color, upperBiome.color, t).xyz, avg);

    }


float SplineCalc(float t, float K1,float C1,float C2,float K2  )
{
    float t3 = pow(1 - t, 3);
    float t2 = pow(1 - t, 2);
    float t1 = 1 - t;

    float h =
             t3 * K1
            + 3 * t2 * t * C1
            + 3 * t1 * t * t * C2
            + t * t * t * K2;
    return h;
}

