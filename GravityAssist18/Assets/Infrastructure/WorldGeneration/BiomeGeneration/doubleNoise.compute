#pragma kernel CalculateHeight

#include "noiseSimplex.cginc"



struct Biome
{
    float height;
    float t;
    float amplitude;
    float smoothness;
    float seed;
    
};

float BiomeGradient;
float BiomeAmplitude;
float BiomeSmoothness;
float BiomeSeed;

float warpOffset;
float warpMult;
float heightMult;
float maxHeight;

int texRes;
int nBiomes;
int Center;


RWTexture2D<float4> Result;
RWStructuredBuffer<Biome> BiomeBuffer;
RWStructuredBuffer<float4> heightMap;


float fractalize(float amplitude, float seed, float smoothness,float base, int2 id)
{
   
    const int octaves = 1;
    float frequency = 1.0 / smoothness;
    
    float y = 0;
    for (int i = 0; i < octaves; i++)
    {
        y += amplitude * snoise(id.xy * frequency + seed);
        frequency *= 2;
        amplitude *= 1.0 / 2;
    }
    return y + base;
}

float FractalizeAndPreturb(float amplitude, float seed, float smoothness, int2 id, float warpOffset, float warpMult,float base)
{
    float2 q = float2(fractalize(amplitude, seed, smoothness, base, id), fractalize(amplitude, seed, smoothness, base, id + warpOffset));
    return fractalize(amplitude, seed, smoothness, base,    id + warpMult * q);
}

float3 AproxLerp(RWStructuredBuffer<float> values,int nValues, float myValue)
{
    
}


[numthreads(8, 8, 1)]
void CalculateHeight(uint3 id : SV_DispatchThreadID)
{
    float biome_t = FractalizeAndPreturb(BiomeAmplitude, BiomeSeed, BiomeSmoothness, id.xy, warpOffset, warpMult,0.5f) - distance(id.xy, Center) * BiomeGradient;
    Biome lowerBiome = BiomeBuffer[0];
    Biome upperBiome = BiomeBuffer[nBiomes - 1];
    float lower_t = -1e14;
    float upper_t = 1e14;
    for (int i = 0; i < nBiomes; i++)
    {
        Biome biome = BiomeBuffer[i];
        if (biome.t < biome_t && biome.t > lower_t)
        {
            lowerBiome = biome;
            lower_t = biome.t;
        }
        else if (biome.t > biome_t && biome.t < upper_t)
        {
            upperBiome = biome;
            upper_t = biome.t;
        }
    }
    float t = (biome_t - lower_t) / (upper_t - lower_t);
    
    float lowerHeight = FractalizeAndPreturb(lowerBiome.amplitude, lowerBiome.seed, lowerBiome.smoothness, id.xy, warpOffset, warpMult,lowerBiome.height);
    float upperHeight = FractalizeAndPreturb(upperBiome.amplitude, upperBiome.seed, upperBiome.smoothness, id.xy, warpOffset, warpMult, upperBiome.height);
    float myHeight = lerp(lowerHeight, upperHeight, t) * heightMult;
    heightMap[id.x + id.y * texRes] = float4(myHeight,0,0,0) ;
    
    AllMemoryBarrierWithGroupSync();
    float3 normal = float3(0,0,0);
    if(id.x > 0 && id.y > 0 && id.x < texRes && id.y < texRes)
    {
    float dWestdy = heightMap[id.x  -1 + id.y * texRes].x - myHeight;
    float dNorthWestdy = heightMap[id.x  -1 + (id.y + 1) * texRes].x - myHeight;
    float dNorthdy = heightMap[id.x + (id.y + 1) * texRes].x - myHeight;
    float dEastdy = heightMap[id.x + 1 + (id.y ) * texRes].x - myHeight;
    float dSouthEastdy = heightMap[id.x + 1 + (id.y - 1) * texRes].x - myHeight;
    float dSouthdy = heightMap[id.x + (id.y - 1) * texRes].x - myHeight;
    

    float3 westVec = float3(-1, dWestdy , 0);
    float3 northWestVec = float3(-1, dNorthWestdy, 1);
    float3 northVec = float3(0, dNorthdy , 1);
    float3 eastVec = float3(1, dEastdy , 0);
    float3 southEastVec = float3(1, dSouthEastdy , -1);
    float3 southVec = float3(0, dSouthdy,-1);

    
    float3 normal1 = (normalize(cross( westVec,northWestVec)));
    float3 normal2 = (normalize(cross(northWestVec, northVec)));
    float3 normal3 = (normalize(cross(northVec, eastVec)));
    float3 normal4 = (normalize(cross(eastVec, southEastVec)));
    float3 normal5 = (normalize(cross(southEastVec, southVec)));
    float3 normal6 = (normalize(cross(southVec, westVec)));


    normal = normal1;
    }
        
    AllMemoryBarrierWithGroupSync();
    Result[id.xy] = float4(normal, myHeight / heightMult);
    heightMap[id.x + id.y * texRes] = float4(normal, myHeight);
}


float SplineCalc(float t, float K1, float C1, float C2, float K2)
{
    float t3 = pow(1 - t, 3);
    float t2 = pow(1 - t, 2);
    float t1 = 1 - t;

    float h =
             t3 * K1
            + 3 * t2 * t * C1
            + 3 * t1 * t * t * C2
            + t * t * t * K2;
    return h;
}





    //AllMemoryBarrierWithGroupSync();
    
    //float avg = 0;
    //float deltaAvg = 0;
   
    
    //for (int x = -deltaArea; x <= deltaArea; x++)
    //{
    //    for (int y = -deltaArea; y <= deltaArea; y++)
    //    {
    //        if (!(x == 0 && y == 0))
    //        {
    //            float val = heightMap[id.x + x + (id.y + y) * TextureResolution];
    //            avg = avg + val;
    //            deltaAvg += (abs(myHeight - val) / sqrt(x * x + y * y));
    //        }
    //    }
    //}

  
    //float div = ( deltaArea*2 + 1) * (deltaArea*2 + 1)-1;
    //avg = avg / div;
    
    //lowerHeight = -1e14;
    //upperHeight = 1e14;

    //ColorZone LowerHeightZone = ColorZoneBuffer[0];
    //ColorZone upperHeightZone = ColorZoneBuffer[nColorZones]; 
    
    //for (i = 0; i < nColorZones; i++)
    //{
    //    ColorZone zone = ColorZoneBuffer[i];
    //    if(zone.height > lowerHeight && zone.height < myHeight)
    //    {
    //        lowerHeight = zone.height;
    //        LowerHeightZone = zone;
    //    }
    //    if (zone.height < upperHeight && zone.height > myHeight)
    //    {
    //        upperHeight = zone.height;
    //        upperHeightZone = zone;
    //    }
    //}

    //float color_t = (myHeight - lowerHeight) / (upperHeight - lowerHeight);
    //float3 lowCol = LowerHeightZone.color.rgb;
    //float3 upCol = upperHeightZone.color.rgb;
    //float3 colFlat = lerp(lowCol, upCol, color_t);
    
    //lowCol = LowerHeightZone.color2.rgb;
    //upCol = upperHeightZone.color2.rgb;
    //float3 colGrad = lerp(lowCol, upCol, color_t);
    //float grad_t = (deltaAvg - minGradThresh) / (maxGradThresh - minGradThresh);
    //grad_t = min(max(0, grad_t), 1);
    //float3 col = lerp(colFlat, colGrad, grad_t);

    ////if(deltaAvg > maxGradThresh)
    ////{
    ////    Result[id.xy] = float4(0, 1, 0, myHeight); ///float4(col, myHeight);
    ////}
    ////else if (deltaAvg > minGradThresh)
    ////{
    ////    Result[id.xy] = float4(1, 0, 0, myHeight); ///float4(col, myHeight);
    ////}
    ////else
    ////{
    ////    Result[id.xy] = float4(0, 0, 0, myHeight); ///float4(col, myHeight);
    ////}