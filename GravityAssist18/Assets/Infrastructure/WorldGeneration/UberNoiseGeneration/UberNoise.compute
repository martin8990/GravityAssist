#pragma kernel CalculateHeight
#include "noiseSimplex.cginc"


struct NoiseLayer
{

    float amplitude;
    float smoothness;
    float fractals;
    float seed;
    float2 Warp;
    float mult;
    float sharpness;
    float4 color;

};

RWTexture2D<float4> Result;
RWStructuredBuffer<NoiseLayer> NoiseLayerBuffer;
int nLayers;
int Center;



float FBM(float seed, float smoothness, int2 id)
{
    float2 pos = (id) / (smoothness);
    float val = 0;
   
    val = snoise(pos.xy + uint2(seed, seed));
    

    return val; //lerp(-amplitude, amplitude, val);
}

float fractalize(float amplitude, float fractals, float seed, float smoothness, int2 id)
{
    float2 pos = (id) / (smoothness);
    float val = 0;
    for (int i = 0; i < fractals; i++)
    {
        val += ((snoise((pos.xy + uint2(seed, seed)) * pow(2, i)) + 1.0) / 2.0) / pow(2, i);
    }

    return val; //lerp(-amplitude, amplitude, val);
}

float fractalizeAbs(float amplitude, float fractals, float seed, float smoothness, int2 id)
{
    float2 pos = (id) / (smoothness);
    float val = 0;
    for (int i = 0; i < fractals; i++)
    {
        val += ((snoise((pos.xy + uint2(seed, seed)) * pow(2, i)) + 1.0) / 2.0) / pow(2, i);
    }

    return lerp(0, amplitude, val);
}
[numthreads(8, 8, 1)]
void CalculateHeight(uint3 id : SV_DispatchThreadID)
{
    float featureNoise[9];
    float2 Grad = float2(0, 0);
    
    for (int i = 0; i < nLayers;i++)
    {
        NoiseLayer l1 = NoiseLayerBuffer[i];
        for (int x = 0; x <= 1; x++)
        {
            for (int y = 0; y <= 1; y++)
            {
                float2 q = float2(FBM(l1.seed, l1.smoothness, id.xy)
            , FBM(l1.seed, l1.smoothness, id.xy + l1.Warp));

                float mNoise = FBM(l1.seed, l1.smoothness, id.xy + l1.mult * q);
                featureNoise[x + y * 2] += (0.5 + mNoise) * l1.amplitude;
        }
    }
    Result[id.xy] = float4(featureNoise,0,0,featureNoise);

}


