// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateHeight

#include "noiseSimplex.cginc"

struct HeightContour
{
    float2 height;
    float2 radius;
    float2 center;
    
    float amplitude;
    float smoothness;
    float fractals;
    float seed;
};


RWTexture2D<float4> Result;
RWStructuredBuffer<HeightContour> HeightContourBuffer;
int nContours;

float fractalize(float amplitude,float fractals, float seed,float smoothness, int2 id)
{
    float2 pos = (id) / (smoothness);
    float val = 0;
    for (int i = 0; i < fractals; i++)
    {
        val += ((snoise((pos.xy + uint2(seed, seed)) * pow(2, i)) + 1.0) / 2.0) / pow(2, i);
    }

    return lerp(-amplitude, amplitude, val);
}

[numthreads(8,8,1)]
void CalculateHeight (uint3 id : SV_DispatchThreadID)
{
    float Height = 0;
    float tw = 0;
    for (int i = 0; i < nContours; i++)
    {
        HeightContour hc = HeightContourBuffer[i];
        float Angle = atan2(id.y - hc.center.y, id.x - hc.center.x);
        float Radius = distance(id.xy, hc.center);
        
        float t = (Radius - hc.radius.x) / (hc.radius.y - hc.radius.x);
        if (t>=0 && t<=1)
        {
            float w = (1.0 / pow(min(abs(Radius - hc.radius.x), abs(Radius - hc.radius.y)), 2));
            Height += (lerp(hc.height.x, hc.height.y, t)
            + fractalize(hc.amplitude, hc.fractals, hc.seed, hc.smoothness, id.xy)) * w;
            tw += w;
        }         
    }
    Result[id.xy] = float4(Height/tw,0,0,0);
}
