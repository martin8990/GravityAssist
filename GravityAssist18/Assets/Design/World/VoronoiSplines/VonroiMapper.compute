#pragma kernel MapVonoroi
#pragma kernel MapVonoroi2
#pragma kernel MapVonoroi3

RWTexture2D<float4> Result;
RWStructuredBuffer<float3> VonoroiBuffer;
RWStructuredBuffer<int> VonoroiMap;
RWStructuredBuffer<float> HeightSamples;

int nPoints;
int radiiPerAngle;
int VonoroiRes;
float radiusUnit;
int CoordX;
int CoordY;
int Resolution;

[numthreads(8, 8, 1)]
void MapVonoroi3(uint3 id : SV_DispatchThreadID)
{
    

    
    int myId1 = 0;
    int myId2 = 0;
    int myId3 = 0;
    float2 Offset = int2(CoordX, CoordY) * Resolution;
    float height = 0;
    float tw = 0;
    for (int i = 0; i < nPoints; i++)
    {

        float ds = pow(distance(VonoroiBuffer[i].xz, float2(id.xy) + Offset), 3);
        height = height + 1/ds * VonoroiBuffer[i].y;
        tw = tw + 1/ds;
        
    }
    
    height = height / tw;
    //Result[id.xy] = float4(myId1 / (float) nPoints, myId2 / (float) nPoints, myId3 / (float) nPoints, 1);
    Result[id.xy] = float4(height, 0, 0, 1);

}


[numthreads(8,8,1)]
void MapVonoroi(uint3 id : SV_DispatchThreadID)
{
    float minDist = 100000000.0;
    int myId = 0;
    for (int i = 0; i < nPoints; i++)
    {
        float2 Offset = int2(CoordX, CoordX) * Resolution;
        float dist = distance(VonoroiBuffer[i].xz, float2(id.xy) + Offset);
        if(minDist>dist)
        {
            minDist = dist;
            myId = i;
        }
    }

    Result[id.xy] = float4(myId / (float)nPoints, 0, 0, 1);
    VonoroiMap[id.x + id.y * VonoroiRes] = myId;
}

[numthreads(8, 8, 1)]
void MapVonoroi2(uint3 id : SV_DispatchThreadID)
{
    float minDist1 = 100000000.0;
    float minDist2 = 100000000.0;
    float minDist3 = 100000000.0;
    
    int myId1 = 0;
    int myId2 = 0;
    int myId3 = 0;
    float2 Offset = int2(CoordX, CoordY) * Resolution;
    for (int i = 0; i < nPoints; i++)
    {
        
        float dist = distance(VonoroiBuffer[i].xz, float2(id.xy) + Offset);
        if (minDist1 > dist)
        {
            minDist3 = minDist2;
            minDist2 = minDist1;
            minDist1 = dist;
            myId3 = myId2;
            myId2 = myId1;
            myId1 = i;
        }
        else if (minDist2 > dist)
        {
            minDist3 = minDist2;
            minDist2 = dist;
            myId3 = myId2;
            myId2 = i;
        }
        else if (minDist3 > dist)
        {
            minDist3 = dist;
            myId3 = i;
        }
        
    }

    float w1 = 1.0 / (minDist1 * minDist1);
    float w2 = 1.0 / (minDist2 * minDist2);
    float w3 = 1.0 / (minDist3 * minDist3);
    float tw = w1 + w2 + w3;
    float r1 = VonoroiBuffer[myId1].y;
    float r2 = VonoroiBuffer[myId2].y;
    float r3 = VonoroiBuffer[myId3].y;
    
    float res = (w1 * r1 + w2 * r2 + w3 * r3) / tw;
    //Result[id.xy] = float4(myId1 / (float) nPoints, myId2 / (float) nPoints, myId3 / (float) nPoints, 1);
    Result[id.xy] = float4(res,0,0,1);

}


struct TerrainPoint
{
    float3 Position;
    int NNeighbours;
    int StartingIndex;
};
RWStructuredBuffer<TerrainPoint> TerrainPointBuffer;

struct TerrainSample
{
    float Height;
    float Angle;
};
RWStructuredBuffer<TerrainSample> TerrainSampleBuffer;


[numthreads(8, 8, 1)]
void TerrainGen(uint3 id : SV_DispatchThreadID)
{
    float minDist = 100000000.0;
    int myId = 0;
    float dist = 0;
    for (int i = 0; i < nPoints; i++)
    {
        dist = distance(TerrainPointBuffer[i].Position.xz, float2(id.xy));
        if (minDist > dist)
        {
            minDist = dist;
            myId = i;
        }
    }
    float rawRadiusId = dist / radiusUnit;
    
    int radiusIdLow = floor(rawRadiusId);
    int radiusIdHigh = radiusIdLow + 1;
    float t = (rawRadiusId - radiusIdLow);

    TerrainPoint tPoint = TerrainPointBuffer[i];
    float myAngle = atan2(id.y - tPoint.Position.z, id.x - tPoint.Position.x);

    int minAngleId = 0;
    int maxAngleId = 1;
    
    for (i = 1; i < tPoint.NNeighbours; i++)
    {
        int myid = tPoint.StartingIndex + i * radiiPerAngle + radiusIdLow;
        float dAngle = myAngle - TerrainSampleBuffer[myid].Angle;
        if(dAngle > 0)
        {
            maxAngleId = i;
            minAngleId = tPoint.NNeighbours - 1;
            break;
        }
    }
    float A1 = TerrainSampleBuffer[tPoint.StartingIndex + minAngleId * radiiPerAngle + radiusIdLow].Angle;
    float A2 = TerrainSampleBuffer[tPoint.StartingIndex + maxAngleId * radiiPerAngle + radiusIdLow].Angle;

    float Angle_t = (myAngle - A1) / (A2 - A1);
    

    TerrainSample r1A1 = TerrainSampleBuffer[tPoint.StartingIndex + minAngleId * radiiPerAngle + radiusIdLow];
    TerrainSample r2A1 = TerrainSampleBuffer[tPoint.StartingIndex + minAngleId * radiiPerAngle + radiusIdHigh];
    TerrainSample r1A2 = TerrainSampleBuffer[tPoint.StartingIndex + maxAngleId * radiiPerAngle + radiusIdLow];
    TerrainSample r2A2 = TerrainSampleBuffer[tPoint.StartingIndex + maxAngleId * radiiPerAngle + radiusIdHigh];

    float A1h = lerp(r1A1.Height, r2A1.Height,t);
    float A2h = lerp(r1A2.Height, r2A2.Height,t);
    float h = lerp(A1h, A2h, Angle_t);
    
    Result[id.xy] = float4(h, 0, 0, 1);
}
